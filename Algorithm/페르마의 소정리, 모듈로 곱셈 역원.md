# 페르마의 소정리와 모듈로 곱셈 역원

---

정수론과 조합론 문제에서 나눗셈을 처리하는 핵심 개념에 대한 내용이다

## 정의

### 페르마의 소정리 (Fermat's Little Theorem)

**소수 p와 p의 배수가 아닌 정수 a에 대해 성립하는 정리**

$$a^{p-1} \equiv 1 \pmod{p}$$
- $$a^{p-1}를 p로 나누면 나머지는 항상 1이다
- p가 소수이고, $\gcd(a, p) = 1$일 때 성립
- 양변에 $a^{-1}$을 곱하면: **$a^{p-2} \equiv a^{-1} \pmod{p}$**

### 모듈로 곱셈 역원 (Modular Multiplicative Inverse)

**$a \times x \equiv 1 \pmod{m}$을 만족하는 x를 a의 모듈로 m에 대한 곱셈 역원이라 한다**

- 나눗셈 대신 곱셈으로 표현: $\frac{a}{b} \pmod{m} = a \times b^{-1} \pmod{m}$
- m이 소수일 때, 페르마의 소정리로 쉽게 구할 수 있음
- 역원이 존재하려면 $\gcd(a, m) = 1$이어야 함

## 왜 필요한가?

**모듈로 연산에서 나눗셈 처리**

- 큰 수의 나눗셈을 1,000,000,007 같은 소수로 나눈 나머지로 출력해야 할 때
- $(a / b) \bmod \text{MOD} \neq (a \bmod \text{MOD}) / (b \bmod \text{MOD})$ → **나눗셈은 모듈로 연산과 분배 불가**
- 조합 계산 시: $\binom{n}{r} = \frac{n!}{r! \times (n-r)!}$ → 역원을 이용해 해결

**알고리즘 문제의 필수 기법**

- 조합론 문제의 90% 이상에서 등장
- 확률, 기댓값 계산 문제
- DP에서 나눗셈이 필요한 경우

## 작동 원리

### 기본 아이디어

1. **일반 나눗셈**: $a / b$
2. **모듈로 역원 이용**: $a \times b^{-1} \pmod{m}$
3. **페르마의 소정리**: $b^{-1} \equiv b^{m-2} \pmod{m}$ (m이 소수일 때)

### 왜 $a^{p-2}$가 역원인가?

$$
\begin{align*}
a^{p-1} &\equiv 1 \pmod{p} \quad &\text{(페르마의 소정리)} \\
a \times a^{p-2} &\equiv 1 \pmod{p} \quad &\text{(양변을 정리)} \\
\end{align*}
$$

**따라서 $a^{p-2}$가 a의 역원!**

### 예시: 5의 역원 구하기 (mod 7)

$$
\begin{align*}
5^{7-2} &= 5^5 = 3125 \\
3125 &\equiv 3 \pmod{7}
\end{align*}
$$

**검증**: $5 \times 3 = 15 \equiv 1 \pmod{7}$ ✓

## 구현

### 기본 구현 (Java)

```java
class ModularInverse {
    static final long MOD = 1_000_000_007;

    // 분할 정복을 이용한 거듭제곱 (O(log n))
    public static long power(long a, long b, long mod) {
        long result = 1;
        a %= mod;
        
        while (b > 0) {
            if (b % 2 == 1) {
                result = (result * a) % mod;
            }
            a = (a * a) % mod;
            b /= 2;
        }
        
        return result;
    }

    // 페르마의 소정리를 이용한 모듈로 역원 (O(log MOD))
    public static long modInverse(long a, long mod) {
        return power(a, mod - 2, mod);
    }

    // 모듈로 나눗셈: a / b (mod MOD)
    public static long modDivide(long a, long b, long mod) {
        return (a % mod * modInverse(b, mod)) % mod;
    }
}
```

### 조합 계산 예시

```java
class Combination {
    static final long MOD = 1_000_000_007;
    static final int MAX = 100_000;
    static long[] factorial = new long[MAX + 1];

    // 팩토리얼 전처리 (O(n))
    public static void preprocess() {
        factorial[0] = 1;
        for (int i = 1; i <= MAX; i++) {
            factorial[i] = (factorial[i - 1] * i) % MOD;
        }
    }

    // nCr 계산 (O(log MOD))
    public static long nCr(int n, int r) {
        if (r > n || r < 0) return 0;
        
        long numerator = factorial[n];
        long denominator = (factorial[r] * factorial[n - r]) % MOD;
        
        return (numerator * ModularInverse.modInverse(denominator, MOD)) % MOD;
    }
}
```

### 사용 예제

```java
public class Main {
    public static void main(String[] args) {
        ModularInverse.MOD = 1_000_000_007;
        
        // 예제 1: 10 / 3 (mod 10^9+7)
        long result = ModularInverse.modDivide(10, 3, ModularInverse.MOD);
        System.out.println("10 / 3 (mod 10^9+7) = " + result);
        
        // 예제 2: 조합 계산
        Combination.preprocess();
        System.out.println("10C3 = " + Combination.nCr(10, 3));
        System.out.println("100C50 mod 10^9+7 = " + Combination.nCr(100, 50));
    }
}
```

## 시간 복잡도 비교

### 거듭제곱 계산: $a^n$ 구하기

**일반적인 방법 (반복문)**
```java
// O(n) - n번 곱셈
long result = 1;
for (int i = 0; i < n; i++) {
    result *= a;
}
```

**분할 정복 방법 (빠른 거듭제곱)**
```java
// O(log n) - log n번 곱셈
// a^8 = ((a^2)^2)^2 처럼 제곱을 반복
while (b > 0) {
    if (b % 2 == 1) result *= a;
    a *= a;
    b /= 2;
}
```

### 성능 차이

| 방법 | 시간 복잡도 | $n=10^9$일 때 연산 횟수 |
|------|------------|---------------------|
| 일반 반복 | O(n) | 약 10억 번 |
| 분할 정복 | O(log n) | 약 30번 |

**→ 페르마의 소정리로 역원 구하기: O(log MOD) ≈ O(30)**

## 어디에 사용될까?

### 알고리즘 문제

- **조합론**: nCr mod P 계산
- **확률/기댓값**: 분수 계산 후 모듈로 출력
- **동적 계획법**: DP 상태에서 나눗셈이 필요한 경우
- **수학 문제**: 역원이 명시적으로 필요한 문제

### 실전 활용

- **암호학**: RSA 암호, 디지털 서명
- **해시 함수**: 분산 해싱, 블룸 필터
- **난수 생성**: 선형 합동 생성기
- **오류 정정 코드**: Reed-Solomon 코드

## 주의사항

### MOD가 소수여야 함

**페르마의 소정리는 m이 소수일 때만 성립**

```java
// ✓ 가능: 1_000_000_007은 소수
modInverse(5, 1_000_000_007);

// ✗ 불가능: 1_000_000_008은 소수가 아님
// 이 경우 확장 유클리드 알고리즘 사용
```

### gcd(a, m) = 1 확인

**역원이 존재하려면 a와 m이 서로소여야 함**

```java
// 역원이 없는 경우
modInverse(6, 9);  // gcd(6,9) = 3 ≠ 1 → 역원 없음!
```

### 오버플로우 주의

**곱셈 중간 과정에서 오버플로우 발생 가능**

```java
// 매 연산마다 모듈로 적용
result = (result * a) % MOD;  // ✓
// result = result * a % MOD;  // ✗ 오버플로우 가능
```

### 전처리 활용

**조합을 여러 번 구할 때는 팩토리얼 전처리**

```java
// 한 번만 계산
factorial[i] = (factorial[i-1] * i) % MOD;

// 이후 O(log MOD)에 nCr 계산 가능
```

---

### 응용 문제

https://www.acmicpc.net/problem/11401 - 이항 계수 3

https://www.acmicpc.net/problem/13977 - 이항 계수와 쿼리

---