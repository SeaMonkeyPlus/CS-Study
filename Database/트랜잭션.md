# 트랜잭션 (Transaction)

---

데이터베이스에서 데이터의 일관성과 무결성을 보장하기 위한 작업 단위

## 정의

**하나의 논리적 작업 단위를 구성하는 연산들의 집합**

- 여러 개의 쿼리를 하나의 작업으로 묶어서 처리
- All or Nothing: 전부 성공하거나 전부 실패
- 데이터베이스의 일관성을 유지하는 핵심 메커니즘
- 은행 송금, 주문 처리 등 중요한 비즈니스 로직에 필수

## 왜 트랜잭션이 필요한가?

**트랜잭션 없이 발생할 수 있는 문제**

```sql
-- A계좌에서 10만원 출금
UPDATE account SET balance = balance - 100000 WHERE id = 'A';

-- 여기서 시스템 장애 발생! ❌

-- B계좌에 10만원 입금 (실행 안 됨)
UPDATE account SET balance = balance + 100000 WHERE id = 'B';
```

결과: A계좌에서만 돈이 빠지고 B계좌에는 입금 안 됨 → **데이터 불일치**

**트랜잭션 사용 시**

```sql
START TRANSACTION;

UPDATE account SET balance = balance - 100000 WHERE id = 'A';
UPDATE account SET balance = balance + 100000 WHERE id = 'B';

COMMIT;  -- 모두 성공 시
-- ROLLBACK;  -- 하나라도 실패 시
```

## 트랜잭션 상태

트랜잭션의 생명주기는 다음 5가지 상태로 구분됩니다.

```
Active → Partially Committed → Committed
  ↓              ↓
Failed ← ← ← ← Aborted
```

| 상태                           | 설명                                     | 예시                     |
| ------------------------------ | ---------------------------------------- | ------------------------ |
| **Active (활성)**              | 트랜잭션이 실행 중인 상태                | SQL 쿼리 실행 중         |
| **Partially Committed (부분)** | 마지막 연산까지 실행했지만 커밋 전       | COMMIT 직전              |
| **Committed (완료)**           | 트랜잭션이 성공적으로 완료되어 영구 반영 | COMMIT 완료              |
| **Failed (실패)**              | 정상 실행이 불가능한 상태                | 제약조건 위반, 에러 발생 |
| **Aborted (철회)**             | 트랜잭션이 취소되고 롤백된 상태          | ROLLBACK 완료            |

## 격리 수준 (Isolation Level)

동시성과 일관성의 트레이드오프를 조절하는 4가지 수준

### 1. READ UNCOMMITTED (레벨 0)

**커밋되지 않은 데이터도 읽을 수 있음**

- 가장 낮은 격리 수준
- ❌ Dirty Read 발생 가능
- 거의 사용하지 않음

```sql
-- Transaction A
UPDATE account SET balance = 50000 WHERE id = 1;
-- 아직 커밋 안 함

-- Transaction B
SELECT balance FROM account WHERE id = 1;  -- 50000 조회 (Dirty Read)

-- Transaction A
ROLLBACK;  -- A가 롤백하면 B가 읽은 데이터는 존재하지 않는 값
```

### 2. READ COMMITTED (레벨 1)

**커밋된 데이터만 읽을 수 있음**

- 대부분의 DBMS 기본 설정 (Oracle, PostgreSQL)
- ✅ Dirty Read 방지
- ❌ Non-Repeatable Read 발생 가능

```sql
-- Transaction A
SELECT balance FROM account WHERE id = 1;  -- 100000

-- Transaction B
UPDATE account SET balance = 50000 WHERE id = 1;
COMMIT;

-- Transaction A
SELECT balance FROM account WHERE id = 1;  -- 50000 (값이 변경됨)
```

### 3. REPEATABLE READ (레벨 2)

**트랜잭션 내에서 같은 데이터를 여러 번 읽어도 항상 같은 값**

- MySQL InnoDB 기본 설정
- ✅ Dirty Read, Non-Repeatable Read 방지
- ❌ Phantom Read 발생 가능 (MySQL은 MVCC로 방지)

```sql
-- Transaction A
SELECT * FROM account WHERE balance >= 100000;  -- 2건

-- Transaction B
INSERT INTO account VALUES (3, 150000);
COMMIT;

-- Transaction A
SELECT * FROM account WHERE balance >= 100000;  -- 여전히 2건
-- (MySQL은 Phantom Read도 방지하지만, 표준에서는 발생 가능)
```

### 4. SERIALIZABLE (레벨 3)

**완전한 격리, 순차적 실행과 동일한 결과**

- 가장 높은 격리 수준
- ✅ 모든 이상 현상 방지
- ❌ 동시성 크게 저하, 성능 느림

```sql
-- 트랜잭션들이 마치 한 번에 하나씩 실행되는 것처럼 동작
-- 읽기에도 Lock이 걸려서 다른 트랜잭션의 수정 불가
```

### 격리 수준 비교표

| 격리 수준        | Dirty Read | Non-Repeatable Read | Phantom Read | 성능     |
| ---------------- | ---------- | ------------------- | ------------ | -------- |
| READ UNCOMMITTED | 발생       | 발생                | 발생         | ⚡⚡⚡⚡ |
| READ COMMITTED   | 방지       | 발생                | 발생         | ⚡⚡⚡   |
| REPEATABLE READ  | 방지       | 방지                | 발생\*       | ⚡⚡     |
| SERIALIZABLE     | 방지       | 방지                | 방지         | ⚡       |

\*MySQL InnoDB는 Phantom Read도 방지

## 동시성 문제

### Dirty Read (더티 리드)

**커밋되지 않은 데이터를 읽는 현상**

- READ UNCOMMITTED에서 발생
- 롤백된 데이터를 읽을 수 있어 심각한 문제

### Non-Repeatable Read (반복 불가능한 읽기)

**같은 데이터를 두 번 읽었을 때 값이 다른 현상**

- READ COMMITTED에서 발생
- 다른 트랜잭션의 UPDATE가 원인

### Phantom Read (팬텀 리드)

**같은 조건으로 조회했을 때 결과 행의 개수가 달라지는 현상**

- REPEATABLE READ에서 발생
- 다른 트랜잭션의 INSERT/DELETE가 원인

## 트랜잭션 제어 명령어

### MySQL

```sql
-- 트랜잭션 시작
START TRANSACTION;
-- 또는
BEGIN;

-- 작업 수행
INSERT INTO orders (user_id, amount) VALUES (1, 50000);
UPDATE inventory SET stock = stock - 1 WHERE product_id = 100;

-- 성공 시 커밋
COMMIT;

-- 실패 시 롤백
ROLLBACK;

-- 세이브포인트 (부분 롤백)
SAVEPOINT sp1;
-- ... 작업 ...
ROLLBACK TO sp1;  -- sp1 시점으로 롤백
```

### 자동 커밋 설정

```sql
-- 자동 커밋 확인
SELECT @@autocommit;

-- 자동 커밋 비활성화
SET autocommit = 0;

-- 자동 커밋 활성화
SET autocommit = 1;
```

## 락(Lock)

트랜잭션 격리를 구현하는 핵심 메커니즘

### 공유 락 (Shared Lock, S-Lock)

**읽기 락 - 여러 트랜잭션이 동시에 읽기 가능**

```sql
SELECT * FROM account WHERE id = 1 LOCK IN SHARE MODE;
-- 또는 (MySQL 8.0+)
SELECT * FROM account WHERE id = 1 FOR SHARE;
```

- 다른 트랜잭션도 읽기 가능
- 다른 트랜잭션의 쓰기는 대기

### 배타 락 (Exclusive Lock, X-Lock)

**쓰기 락 - 독점적 접근, 다른 트랜잭션 접근 불가**

```sql
SELECT * FROM account WHERE id = 1 FOR UPDATE;
```

- 다른 트랜잭션의 읽기/쓰기 모두 대기
- UPDATE, DELETE 문은 자동으로 X-Lock 획득

### 락 호환성 표

|            | S-Lock  | X-Lock  |
| ---------- | ------- | ------- |
| **S-Lock** | ✅ 허용 | ❌ 대기 |
| **X-Lock** | ❌ 대기 | ❌ 대기 |

## 면접 대비 핵심 질문

### Q1. 트랜잭션이란 무엇이고 왜 필요한가?

**A1.** 트랜잭션은 데이터베이스에서 하나의 논리적 작업 단위를 구성하는 연산들의 집합입니다. 여러 쿼리를 원자적으로 실행하여 데이터의 일관성과 무결성을 보장합니다. 예를 들어 계좌 이체 시 출금과 입금이 모두 성공하거나 모두 실패해야 하는데, 트랜잭션이 없다면 중간에 시스템 장애가 발생했을 때 데이터 불일치가 발생할 수 있습니다.

### Q2. 격리 수준(Isolation Level)에 대해 설명하세요.

**A2.** 격리 수준은 동시성과 일관성의 트레이드오프를 조절하는 설정입니다. 4가지 수준이 있습니다:

1. **READ UNCOMMITTED**: 커밋되지 않은 데이터도 읽을 수 있음 (Dirty Read 발생)
2. **READ COMMITTED**: 커밋된 데이터만 읽음 (Non-Repeatable Read 발생)
3. **REPEATABLE READ**: 트랜잭션 내에서 같은 값 보장 (Phantom Read 발생 가능)
4. **SERIALIZABLE**: 완전한 격리, 가장 안전하지만 성능 저하

실무에서는 READ COMMITTED나 REPEATABLE READ를 주로 사용하며, 상황에 따라 적절한 수준을 선택해야 합니다.

### Q3. @Transactional 어노테이션의 동작 원리는?

**A3.** Spring의 @Transactional은 AOP(Aspect-Oriented Programming)를 기반으로 동작합니다. 프록시 패턴을 사용하여 메서드 실행 전에 트랜잭션을 시작하고, 메서드가 정상 종료되면 커밋, 예외가 발생하면 롤백합니다.

**주의사항:**

- private 메서드에는 적용 안 됨 (프록시 불가)
- 같은 클래스 내부 호출 시 트랜잭션 적용 안 됨
- 체크 예외는 기본적으로 롤백 안 됨 (rollbackFor 설정 필요)

---

## 추가 질문

**Q. 트랜잭션을 너무 길게 가져가면 어떤 문제가 있나요?**

A. 트랜잭션이 길어지면 여러 문제가 발생합니다:

- **락 대기 시간 증가**: 다른 트랜잭션들이 오래 기다려야 함
- **데드락 확률 증가**: 더 많은 자원을 더 오래 점유
- **커넥션 풀 고갈**: DB 커넥션을 오래 점유하여 다른 요청 처리 불가
- **롤백 비용 증가**: 실패 시 되돌려야 할 작업이 많음

따라서 트랜잭션 범위는 꼭 필요한 DB 작업만 포함하도록 최소화해야 합니다.

**Q. 낙관적 락(Optimistic Lock)과 비관적 락(Pessimistic Lock)의 차이는?**

A. 동시성 제어를 위한 두 가지 접근 방식입니다:

**비관적 락 (Pessimistic Lock)**

- 데이터 수정 시 충돌이 발생할 것으로 가정
- 읽는 시점에 락을 걸어서 다른 트랜잭션의 접근 차단
- `SELECT ... FOR UPDATE` 사용
- 충돌이 잦은 경우 유리

**낙관적 락 (Optimistic Lock)**

- 충돌이 드물 것으로 가정
- 락 없이 읽고, 수정 시점에 버전 체크
- 버전 컬럼을 사용하여 충돌 감지
- 충돌이 적은 경우 유리, 성능 좋음

```java
// 낙관적 락 예시
@Entity
public class Product {
    @Version
    private Long version;  // JPA가 자동으로 버전 체크
}
```

**Q. NoSQL에서는 트랜잭션을 왜 잘 안쓸까?**
