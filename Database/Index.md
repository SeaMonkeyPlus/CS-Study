# CS 스터디 25.10.15

# 오늘의 주제: “인덱스”

많이 들어는 봤지만, 정확하게 이해를 해보자.

## 인덱스란 뭘까?

- 인덱스란 RDBMS에서 데이터의 조회 성능을 올리기 위한 자료구조이다.
- 테이블의 형태이며 내부적으로 B+ tree를 사용하여, 이진 검색을 지원한다.
- 예를 들면, 기존에 full-scan을 통해 O(N)의 시간에 name=”백승훈” 을 통해 검색 했다면, 1차 적으로 인덱스 테이블에서 B+ tree의 이진 탐색을 통해 O(log N)의 시간에 name=”백승훈” 인 행의 ROW id를 얻어내어 O(1)의 시간에 찾아내어 결론적으로 O(N) → O(log N) 의 시간 안에 찾아올 수 있는 것이다.

## 그러면 인덱스, 어떨 때 사용해야 할까?

- 인덱스는 INSERT, UPDATE, DELETE 와 같은 “변경” 자주 일어나는 테이블에는 사용을 줄이자.
- 그 이유는 변경이 일어날 때, 인덱스 테이블에도 함께 업데이트가 일어나야 함.
- 그 과정에서 인덱스 테이블의 기존 정보는 지워지지 않고, 그저 사용불가 형태로 남아 있게 됨.
- 그로 인해 인덱스 테이블이 비대해지고, 쿼리의 결과로 인덱스 테이블의 업데이트하는 오버헤드 자체가 일반적인 경우보다 성능이 느려지는 경우가 있을 수 있다.

## 오케이. 그러면 검색 빨라지니까 한 테이블에 인덱스 여러개 걸어볼까?

- 그러면 안됨. 대부분의 경우 성능이 느려지는 결과를 초래함.
- 첫번째로 컬럼의 인덱스 별로 새로운 인덱스 테이블을 만들어야 함 → 저장공간 낭비
- 두번째로 실제로 여러개를 만든다고, 한 쿼리 내에서 이 인덱스를 모두 사용하지 못함
- 세번째로 위에서 말했 듯 업데이트 시 생기는 인덱스 테이블 업데이트 오버헤드가 만약에 인덱스가 1개에서 4개로 늘었다면 말 그대로 4배가 증가하는 셈. 즉, 낭비

## 그러면 어떻게 해? 실제로 많이 쓰는 조합이라면 복합 인덱스를 걸자

- 단, 걸 때, (a,b,c) 순으로 인덱스를 걸었다면 a, ab, abc 조건으로는 인덱스가 동작하지만, b, c, ca 이런 왼쪽 기준으로 정렬되지 않은 순서의 쿼리에선 동작하지 않음.

### 추가질문

- RDBMS, NoSQL 둘 다 인덱싱이 가능한가?
  - 정우 : NoSQL은 해시테이블 형태로 구조가 구성되어 있어서 O(1)로 접근 가능 그래서 인덱싱이 필요없다
  - 답변: 정우의 말이 맞음. 근데 필요없는 경우가 많긴하지만, 인덱싱이 가능한가? 라고 물으면 가능함다. 즉, NoSQL도 인덱싱 지원 O
- PK에는 기본적으로 인덱싱이 적용되어 있는가? 그렇다면 이게 불리하게 작용하나?
  - 진호: 기본적으로 되어있는 것으로 알고 있다.
  - 답변: PK는 자동으로 클러스터드 인덱스가 생성된다. 왜냐? 기본적으로 PK는 물리적 정렬 순서를 제공하기 때문 ㅇㅇ. 즉, PK 자체가 테이블의 정렬 구조이기 때문에 인덱스 처럼 동작하는 것.
  - 인덱스 테이블이 생성되는 건 아니고 정렬 구조라 마치 인덱싱이 된 것 처럼 된다는 뜻.
- 개선법 중에 인덱스를 거는 거랑 쿼리를 개선하는 거랑 어떤 상황에서 어떤 방법이 더 나을지 궁금
  | 상황 | 더 나은 접근 |
  | ---------------------------------------------------------------- | --------------------------------------------------------- |
  | 쿼리가 불필요하게 많은 행을 스캔하거나 불필요한 조인을 수행할 때 | ✅ **쿼리 개선**이 먼저 |
  | 쿼리가 올바르지만, 데이터가 너무 많아 성능이 느릴 때 | ✅ **인덱스 추가** |
  | SELECT 빈도는 높지만, INSERT/UPDATE도 자주 발생함 | ❌ 인덱스는 신중히 (쓰기 성능 저하) |
  | WHERE 조건이 자주 바뀌거나 다양한 칼럼 조합을 씀 | ✅ 쿼리 개선 + 통계 기반 인덱스 전략 (Composite Index 등) |
