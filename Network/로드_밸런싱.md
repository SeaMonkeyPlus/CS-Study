# LB (Load Balancing) - 25.10.31

## 🎯 1. 정의 — 로드 밸런싱이란?

> **로드 밸런싱(load balancing)**은
> 
> 
> 여러 서버로 들어오는 **요청(트래픽)을 효율적으로 분산시켜주는 기술**
> 
> 한 서버에 부하가 집중되지 않게 하여 **성능, 안정성, 확장성**을 높이는 역할
> 

즉, 하나의 서버가 모든 요청을 처리하면 병목이 생기고, 장애가 나면 전체 서비스가 멈추지만

로드 밸런서를 두면 **요청을 여러 서버로 분배**해서 이런 문제를 해결할 수 있음.

---

## ⚙️ 2. 왜 필요한가?

이유는 3가지로 요약돼 👇

| 이유 | 설명 |
| --- | --- |
| 🧠 성능 (Performance) | 트래픽을 여러 서버로 분산시켜, 한 서버에 과부하가 걸리지 않게 함 |
| 🔁 가용성 (Availability) | 한 서버가 다운돼도 다른 서버로 자동 분배되어 서비스 지속 가능 |
| 🚀 확장성 (Scalability) | EC2 인스턴스를 추가하면, 로드 밸런서가 자동으로 트래픽을 새 인스턴스에도 분배 |

---

## 🧱 3. 로드 밸런싱 방식

대표적으로는 이렇게 나뉘어 👇

| 구분 | 설명 | 예시 |
| --- | --- | --- |
| **L4 (전송 계층)** | IP + Port 기반으로 분산, 데이터 내용을 몰라도 빠름 | AWS NLB, HAProxy, F5 |
| **L7 (애플리케이션 계층)** | HTTP, URL, Header, Cookie 등을 기준으로 분산 | AWS ALB, Nginx, Traefik |
- L4는 “트래픽 양만 분배하는 단순한 방식”
- L7은 “요청 내용을 이해하고 똑똑하게 라우팅하는 방식”

---

## 🌐 4. AWS EC2 기반 예시 — 실무형 시나리오

이제 네가 실제로 써봤던 **EC2 + Nginx** 기반으로 구체적인 그림을 그려보자 👇

```
        [사용자]
            │
         (요청)
            │
        ┌───────────┐
        │  AWS ALB  │   ← Application Load Balancer (L7)
        └───────────┘
          /     |     \
       EC2-1  EC2-2  EC2-3
         ↑       ↑      ↑
      (nginx) (nginx) (nginx)

```

### 동작 과정

1. 사용자가 웹사이트에 접속하면
    
    요청이 **AWS Application Load Balancer(ALB)** 로 들어와.
    
2. ALB는 미리 연결된 **Target Group (EC2 인스턴스 묶음)** 을 보고,
    
    트래픽을 **가장 건강한(healthy) 인스턴스**로 분배해.
    
3. 각 EC2 인스턴스 내부에는 **Nginx**가 리버스 프록시 역할을 하거나,
    
    WAS(Spring Boot 등)를 직접 실행하고 있어.
    
4. ALB는 **Health Check (헬스체크)** 를 통해 인스턴스가 죽으면 자동으로 트래픽을 다른 인스턴스로 전송.
5. Auto Scaling Group을 설정하면
    
    트래픽이 늘어날 때 EC2 인스턴스가 자동으로 늘어나고,
    
    줄면 줄어드는 구조로 운영 가능.
    

---

## 🧠 5. 대표적인 분산 알고리즘

로드 밸런서는 트래픽을 나눌 때 이런 기준을 사용해 👇

| 알고리즘 | 설명 |
| --- | --- |
| **Round Robin** | 요청을 순차적으로 서버에 분배 (기본 방식) |
| **Least Connection** | 현재 연결 수가 가장 적은 서버로 보냄 |
| **IP Hash** | 같은 IP는 항상 같은 서버로 (세션 유지 목적) |
| **Weighted Round Robin** | 서버마다 가중치를 설정해 분배 비율 조절 |

예를 들어 Nginx에서 간단히 라운드 로빈 로드 밸런싱을 하려면 이렇게 설정할 수 있어:

```
upstream backend {
    server 10.0.0.1;
    server 10.0.0.2;
    server 10.0.0.3;
}

server {
    location / {
        proxy_pass http://backend;
    }
}

```

---

## ⚖️ 6. 장점과 단점

| 항목 | 내용 |
| --- | --- |
| ✅ **장점** | 트래픽 분산, 장애 대응, 서비스 확장 용이, 비용 효율적 |
| ⚠️ **단점** | 구성 복잡, 로드 밸런서 자체가 장애 시 SPOF(Single Point of Failure) 가능, 세션 관리 어려움 |

단점을 해결하기 위해

- **로드 밸런서 이중화 (이중 ALB, NLB)**
- **Sticky Session or Session Clustering (세션 공유)**
- **Health Check + Auto Scaling**
    
    이런 운영 전략이 같이 쓰여.
    

---

## 💡 7. 면접 답변 예시 (1분 버전)

> 로드 밸런싱은 여러 서버로 들어오는 트래픽을 효율적으로 분산시켜
> 
> 
> 시스템의 성능, 가용성, 확장성을 높이는 기술입니다.
> 
> 예를 들어 AWS 환경에서 Application Load Balancer(ALB)를 사용하면,
> 
> 여러 EC2 인스턴스로 트래픽을 자동으로 분배하고
> 
> 헬스체크를 통해 장애 인스턴스를 제외시킬 수 있습니다.
> 
> 저는 실제로 EC2 위에 Nginx를 올려 웹 서버를 운영해봤는데,
> 
> ALB를 두면 Nginx 서버가 여러 개여도 사용자는 하나의 엔드포인트로 접근할 수 있어
> 
> 관리와 확장 모두 훨씬 효율적이었습니다.
> 
> 단점으로는 세션 유지나 설정 복잡성이 있는데,
> 
> 이를 Sticky Session이나 Redis 세션 공유로 보완할 수 있습니다.
> 

---

## 🚀 8. 한 문장 요약

> 로드 밸런싱은 트래픽 분산을 통한 안정성과 확장성 확보의 핵심 기술이며,
> 
> 
> AWS EC2에서는 **ALB + Auto Scaling Group** 조합이 가장 대표적이고 실용적인 구조다.
> 

---

# 로드 밸런싱 시 세션 문제

“로드 밸런싱”을 이해했으면 그다음 단계로 반드시 나오는 주제가 바로 **세션 관리(Session Management)** — 그중에서도 **Sticky Session**과 **Session Clustering**이야.

이건 “서버를 여러 대로 나누었을 때, 로그인 상태 같은 세션을 어떻게 유지할까?”의 문제

---

## 🧠 1. 배경: 로드밸런서 + 로그인 세션의 충돌

하나의 서버만 있을 땐 아무 문제 없어.

사용자가 로그인하면, 그 서버의 메모리나 세션 스토리지에 “로그인 정보(Session)”이 저장되지.

하지만 로드밸런싱이 들어오면 문제가 생겨 👇

```
[사용자]
   │
[로드 밸런서]
   ├──> [서버 A]
   └──> [서버 B]

```

사용자가 로그인 요청을 보냈을 때는 “서버 A”가 처리해서 세션이 A에 저장됐는데,

다음 요청에서 로드밸런서가 “서버 B”로 트래픽을 보내버리면?

➡️ 서버 B에는 로그인 정보가 없으니까 “다시 로그인 하세요”가 뜨는 거야.

이걸 해결하기 위한 두 가지 대표적인 방법이 바로 **Sticky Session**과 **Session Clustering**이야.

---

## 🍯 2. Sticky Session (세션 고정 방식)

> “한번 붙은 사용자는 계속 같은 서버로만 보내자!”
> 

즉, 로드밸런서가 **세션이 생성된 서버를 기억해두고**,

같은 사용자의 모든 요청을 **항상 그 서버로 라우팅**하는 방식이야.

예시 그림 👇

```
[사용자 A] → [로드밸런서] → [서버 A]
[사용자 B] → [로드밸런서] → [서버 B]

```

A는 계속 A로, B는 계속 B로 가는 거지.

이러면 세션이 서버 A에 저장돼 있어도 문제 없어.

### ✅ 장점

- 구현이 아주 간단함 (로드밸런서 설정만으로 가능)
- 기존 세션 관리 구조를 그대로 유지 가능

### ⚠️ 단점

- 서버 A가 죽으면 A의 세션은 다 날아감 (로그인 다 풀림)
- 트래픽이 고르게 분산되지 않을 수 있음 (특정 서버에 세션이 몰리면 과부하)
- 서버를 추가/제거할 때 세션 불일치 문제 발생

---

## 🤝 3. Session Clustering (세션 공유 방식)

> “세션을 서버끼리 공유하자!”
> 

Sticky Session은 사용자마다 서버를 고정하지만,

**Session Clustering은 모든 서버가 동일한 세션 정보를 공유**하도록 만드는 방식이야.

이걸 구현하는 대표적인 방법이 👇

### 1️⃣ **DB 기반 세션 공유**

모든 세션 정보를 MySQL 같은 DB에 저장해서,

어떤 서버에서 접근하든 같은 데이터를 읽게 하는 방식.

### 2️⃣ **Redis 기반 세션 스토리지**

가장 일반적인 방식이야.

세션을 Redis에 저장해두고, 서버 A든 B든

Redis에서 세션 정보를 가져오면 로그인 상태를 유지할 수 있어.

구조 예시 👇

```
[사용자]
   │
[로드 밸런서]
   ├──> [서버 A]
   └──> [서버 B]
       ↑
     [Redis] ← 세션 정보 저장

```

이러면 로드밸런서가 아무 서버로 보내도 로그인 유지가 돼.

왜냐면 서버들은 세션을 Redis를 통해 **공유하고 있기 때문**이지.

### ✅ 장점

- 서버가 죽어도 세션 유지 가능
- 트래픽이 진짜로 균등하게 분산 가능 (Sticky Session처럼 편향 없음)
- 확장성이 좋음 (스케일 아웃에 유리)

### ⚠️ 단점

- Redis나 DB 같은 중앙 저장소가 추가로 필요함 (관리 복잡도 ↑)
- 네트워크 I/O가 늘어나서 약간의 지연이 생김
- 세션 관리 복잡성 증가

---

## ⚖️ 4. 비교 정리

| 구분 | Sticky Session | Session Clustering |
| --- | --- | --- |
| 개념 | 사용자를 특정 서버에 고정 | 서버 간 세션 데이터 공유 |
| 구현 난이도 | 쉬움 (로드밸런서 설정) | 중간 (Redis/DB 필요) |
| 장애 대응 | 약함 (서버 죽으면 세션 유실) | 강함 (세션 중앙저장소에 있음) |
| 트래픽 분산 | 불균형 가능 | 완전 균등 |
| 확장성 | 낮음 | 높음 |
| 대표 구현 | ALB Sticky Session, Nginx IP Hash | Spring Session + Redis |

---

## ☁️ 5. EC2 + ALB 환경에서의 실제 구성 예시

AWS에서는 보통 이렇게 구성해 👇

### ✅ Sticky Session

ALB(Application Load Balancer) 설정에서

“**Stickiness**” 옵션을 켜면 쿠키 기반으로 특정 사용자를 고정할 수 있어.

- ALB가 `AWSALB`라는 쿠키를 발급
- 이후 해당 사용자는 항상 같은 EC2 인스턴스로 라우팅됨

이건 **로그인 상태 유지가 꼭 필요한데**,

세션 공유 인프라가 없는 상황에서 간단하게 쓰기 좋아.

---

### ✅ Session Clustering

조금 더 제대로 하려면 이렇게 가 👇

```
[사용자]
   ↓
[AWS ALB]
   ↓
[EC2-1]   [EC2-2]   [EC2-3]
   ↓         ↓         ↓
   └───> [Redis (ElastiCache)]

```

모든 EC2는 세션 정보를 Redis(ElastiCache)에 저장.

→ 사용자가 어떤 EC2로 가도 Redis에서 세션을 불러와 로그인 유지.

→ EC2를 늘리거나 줄여도 세션 유지가 끊기지 않음.

Spring Boot에서는 이렇게 설정하면 돼 👇

```java
// build.gradle
implementation 'org.springframework.session:spring-session-data-redis'

// application.yml
spring:
  session:
    store-type: redis

```

이러면 `HttpSession`이 자동으로 Redis에 저장돼.

---

## 💬 6. 한 문장 요약

> Sticky Session은 “한 사용자 = 한 서버”로 고정하는 단순한 방식이고,
> 
> 
> Session Clustering은 “모든 서버가 세션을 공유”하는 구조야.
> 
> **작은 시스템 → Sticky Session**,
> 
> **확장 가능한 서비스 → Redis 기반 Session Clustering** 이 정석이야.
> 

---

---

## 추가 질문

- SPOF(Single Point of Failure) 이게 어떤 문제점인지???
-