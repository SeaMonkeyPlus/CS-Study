# 멀티 스레드 - 25.10.20

# 오늘의 주제 “멀티 스레드”

## 프로세스와 스레드

우선은 컴퓨터 사이언스 적인 측면에서 프로세스와 스레드가 뭔지부터 제대로 알아야겠지?

### 프로세스(Process)

프로세스는 프로그램이 운영체제로부터 실행되어 메모리에 올라온 상태를 “프로세스” 라고 부름.

### 스레드(Thread)

스레드는 프로세스가 실제로 CPU에서 실행되는 “단위” 를 의미 하는 것이다.

하나의 프로세스는 최소 1개의 스레드를 가진다는 것!!

### 여기서 중요한 메모리 구조! *

- 각 프로세스에 할당된 힙, 데이터, 코드 메모리가 있을텐데
- 각 스레드는 이 프로세스의 힙,데이터,코드 메모리를 공유하면서 각자의 스택 메모리만을 독립적으로 가지게 됨!!!

## 그래서 멀티 스레드를 설명하라고 하면, 뭐라고 하면 좋을까?

하나의 프로세스 내에서 여러 실행 단위(스레드)가 공통의 메모리 공간을 공유하며 동시에 실행되는 기법으로, 프로그램의 **응답성** 을 향상시키고 **시스템 자원을 효율적으로 사용하기 위한 병렬 처리 모델**이다.

# 멀티 스레드의 장단점

## ✅ 장점 (Advantages)

| 구분 | 설명 |
| --- | --- |
| **1. 응답성 향상 (Responsiveness)** | 하나의 작업이 오래 걸리더라도, 다른 스레드가 동시에 실행되어 프로그램이 멈추지 않음.예: GUI 프로그램에서 백그라운드 작업을 별도 스레드로 실행하면 UI가 끊기지 않음. |
| **2. 자원 공유 효율 (Resource Sharing)** | 스레드는 프로세스의 **Code/Data/Heap**을 공유하기 때문에, 메모리 사용이 효율적임. 스레드 간 통신(Shared Memory)은 프로세스 간 통신(IPC)보다 훨씬 빠름. |
| **3. CPU 활용 극대화 (Utilization)** | 한 스레드가 I/O로 블로킹될 때, 다른 스레드가 CPU를 활용 가능 → CPU가 놀지 않음.즉, I/O 바운드 작업에 특히 효과적. |
| **4. 병렬 처리 (Parallelism)** | 멀티코어 환경에서 여러 스레드를 각 코어에 배분해 실제로 동시에 실행 가능.CPU 바운드 작업(예: 대규모 연산)에 성능 향상. |
| **5. 작업 단위 분리 (Modularity)** | 독립된 스레드로 기능을 분리하면 코드 구조가 명확해지고 유지보수에 유리.예: 서버에서 요청 처리, 로깅, 모니터링을 각각 스레드로 분리. |
| **6. 빠른 컨텍스트 스위칭** | 프로세스 간 전환보다 스레드 간 전환은 메모리 맵을 공유하므로 훨씬 가볍고 빠름. |

## ❌ 단점 (Disadvantages)

| 구분 | 설명 |
| --- | --- |
| **1. 동기화 문제 (Synchronization Issues)** | 여러 스레드가 공유 데이터를 동시에 수정하면 **Race Condition** 발생.→ `synchronized`, `Lock`, `Atomic` 등의 동기화 기법 필요. |
| **2. 데드락(Deadlock) / 라이브락(Livelock)** | 여러 스레드가 서로의 자원을 기다리다 영원히 멈춤.락 순서나 자원 관리 정책 설계가 매우 중요. |
| **3. 디버깅 및 테스트 어려움** | 실행 순서가 매번 달라져 **재현이 어려운 버그**(Heisenbug)가 발생.특히 동시성 버그는 재현/추적이 어렵다. |
| **4. 스케줄링 오버헤드 (Scheduling Overhead)** | 스레드 전환(Context Switching) 시 CPU 레지스터/캐시 복원 비용이 발생.스레드가 많아질수록 오히려 성능 저하 가능. |
| **5. 안정성 저하 (Stability)** | 스레드는 프로세스 자원을 공유하므로, **한 스레드의 오류가 전체 프로세스에 영향**.예: 한 스레드에서 null pointer 예외로 크래시 → 전체 앱 종료. |
| **6. 메모리 관리 부담 (Thread Stack)** | 스레드마다 별도의 Stack 공간 필요 (보통 512KB~1MB).수천 개 이상 생성하면 메모리 낭비 가능. |
| **7. 설계 복잡성 증가** | 락 설계, 공유 자원 관리, 타임아웃, 데드락 회피 등 고려해야 할 요소가 많아짐. |

## 자. 그러면 우리가 쓰는 Spring Boot, Java 에서는 어떤 패턴으로 많이 쓸까??

우선 기본적으로 http 요청을 우리가 받으면 dispatcherServlet이 처리를 하게 된다는 것을 WAS 시간에 배웠음. 근데 Spring 에서는 내부적으로 모든 “요청” 에 대해서 스레드를 만들고 이미 병렬로 처리하는 것이 기본적이라고 할 수 있음.

### Spring 에서 가장 기본적인 스레드 개념 - Thread Pool

스레드를 만들고 버리는 과정은 비효율적임. 그래서 미리 만들어 놓은 스레드 풀에서 재사용을 하는 개념

- Spring Boot 에서 자주 쓰는 ThreadPoolExecutor의 유형
- `FixedThreadPool` (고정형) 스레드 개수 고정, CPU 바운드 작업에 적합
- `CachedThreadPool` (동적형) 스레드 수 동적, 짧은 I/O 작업에 적합
- `ScheduledThreadPool` (주기형) 주기적 실행, 스케줄링 작업용
- **예시 코드**
    
    ```sql
    @Configuration
    @EnableAsync
    public class AsyncConfig {
    
        @Bean("appExecutor")
        public ThreadPoolTaskExecutor executor() {
            ThreadPoolTaskExecutor ex = new ThreadPoolTaskExecutor();
            ex.setCorePoolSize(5);     // 기본 스레드 5개
            ex.setMaxPoolSize(10);     // 최대 스레드 10개까지 늘어남
            ex.setQueueCapacity(100);  // 대기 큐 (10개 초과 요청이 들어오면 여기에 잠시 대기)
            ex.setThreadNamePrefix("my-pool-");
            ex.initialize();
            return ex;
        }
    }
    
    Async에서 이 ThreadPoolTaskExecutor 를 사용함
    ```
    

### 1) @Async 요청-응답 분리 패턴

그렇다면 비동기 처리를 해주는 @Async 어노테이션은 왜 사용할까?

- 바로 요청과 응답을 하는 스레드를 분리해주기 위함이다.
- 즉, 요청을 받을 때 생성된 스레드는 요청-비즈니스 로직-응답 하나의 모든 과정이 이 스레드에서 하게 되는데 이 과정에서 무거운 I/O 로직이 들어있다면??? 스레드가 블락된 상태로 멈춰있게 된다.
- 따라서, @Async를 이용해 요청 이후 로직을 다른 스레드로 넘긴다면? 현재 스레드는 다시 요청을 받을 수 있게 된다!!!!
- **예시 코드**
    
    ```sql
    @Service
    public class MailService {
    
        @Async  // 이 메서드는 별도의 스레드에서 실행됨
        public void sendEmail(String to) {
            System.out.println(Thread.currentThread().getName());
            // 실제 이메일 전송 로직 (3초 걸린다고 가정)
            try { Thread.sleep(3000); } catch (Exception ignored) {}
            System.out.println("메일 전송 완료!");
        }
    }
    
    @RestController
    @RequiredArgsConstructor
    public class MailController {
    
        private final MailService mailService;
    
        @PostMapping("/send")
        public String sendMail() {
            mailService.sendEmail("user@gmail.com");
            return "메일 전송 중입니다.";  // 바로 응답 (3초 기다리지 않음)
        }
    }
    ```
    

**단, @Async 는 새로운 스레드에서 실행되므로 트랜잭션(@Transactional)이나 ThreadLocal 같은 컨텍스트 정보가 전파되지 않는다.**

### 2) CompletableFuture 클래스. 여러 작업을 병렬로 실행하고 합치기.

여러 개의 비동기 작업을 **병렬로 실행**하고,결과를 **조합(thenCombine)**해서 한 번에 처리할 수 있는 자바 내장 도구.

- 예시 코드
    
    ```sql
    CompletableFuture<String> userFuture = CompletableFuture.supplyAsync(() -> {
        // 사용자 정보 가져오기 (2초)
        sleep(2000);
        return "User Info";
    });
    
    CompletableFuture<String> orderFuture = CompletableFuture.supplyAsync(() -> {
        // 주문 정보 가져오기 (3초)
        sleep(3000);
        return "Order Info";
    });
    
    CompletableFuture<String> combined = userFuture.thenCombine(orderFuture,
        (user, order) -> user + " + " + order);
    
    System.out.println(combined.join()); // 모든 결과가 끝나면 합쳐서 출력
    
    ```
    

정리하자면,
멀티스레드는 CPU와 메모리 자원을 효율적으로 활용하기 위한 기본 구조이며,
Spring Boot에서는 이를 기반으로 ThreadPool, @Async, @Scheduled, CompletableFuture 등 다양한 비동기 패턴을 제공한다.
개발자는 작업 특성(CPU/I/O/주기)에 맞게 적절한 스레드풀을 구성하고,
공유 자원 동기화와 컨텍스트 전파를 신경써야 한다.

## 추가 질문

- dispatcherServlet 이 스레드를 생성할 때, 같이 또 만들어 진다는 건지???
- @Async 의 결과로 새로운 스레드가 생성 되었을 때, 이 스레드에서 실행된 로직의 결과가 리턴될 때 기존 스레드로 돌아가는지, 아니면 새로운 스레드에서 응답까지 다 하는건지 궁금.
    - 특히, service 로직에서 그냥 끝나는 코드라면 ㅇㅋ. 근데 실제로 I/O 상황에서는 Async로 보낸다면 결국 메인 컨트롤러에서 다시 return 값을 받아야 하는데, 새로운 스레드로 갔다면 어떻게 되는지.

## 답변 1

- 서블릿 컨테이너. 즉, 톰캣이 WAS 가 스레드를 만든다!
- 그리고! 이 스레드에서 dispatcherServlet을 호출한다!
- 그리고 dispatcherServlet이 스프링 컨테이너의 bean을 이용해 비즈니스 로직을 처리한다.
- 이런 과정. 즉, 결론적으로 또 만들어 지는 것은 아니다. 왜냐! dispatcherServlet 인스턴스는 서블릿 컨테이너에 보통 1개 존재할 뿐. 스레드들이 공유할 뿐이다~
- 그래서 dispatcherServlet은 스레드 안전하게 설계되어야 함.

## 답변 2

- 우선, 해당 메서드의 리턴 타입이 void일 경우. 응답이 돌아오지 않음.
- 또한, 기존 스레드는 메서드의 리턴을 기다리지 않음. 그대로 아래 로직으로 진행되고 끝남.
- 그런데, 꼭 답변을 받고 싶은 경우 ⇒ Future<T>, CompletableFuture<T> 타입으로 리턴 타입을 지정 한다면, 해당 인터페이스의 join이나 get 메서드를 통해 결과를 동기적으로 받아올 수 있음.
- 그러나 이 방법은 당연하게도 비동기 실행을 동기로 하는 것이나 진배 없기 때문에 의미가 없다.