# 업데이트 과정

## 1. 전체 흐름을 한 줄로 요약하면

> 클라이언트가 “나 버전 X인데 새 거 있어?” → 서버가 “버전 Y 있어, 이 파일 받고, 해시값은 이거야” → 클라가 파일 다운로드 → 해시(체크섬)·서명 검증 → 문제 없으면 설치/교체

![image.png](./image/update_image.png)

---

## 2. 버전 체크 단계

### 2-1. 클라이언트가 서버에 버전 물어봄

앱이 켜질 때, 혹은 주기적으로 대충 이런 요청을 보냄:

```
GET /update/check?app_id=my_app&platform=windows&current_version=1.0.3
```

- `app_id`: 어떤 앱인지
- `platform`: win / mac / android / ios / etc
- `current_version`: 지금 클라이언트가 쓰는 버전

### 2-2. 서버 응답

```json
{
  "has_update": true,
  "latest_version": "1.2.0",
  "download_url": "https://cdn.example.com/my_app_1.2.0.exe",
  "file_size": 52428800,
  "checksum": {
    "algo": "SHA-256",
    "value": "3f9a...abcd"
  },
  "signature": "…(옵션, 전자서명)…",
  "release_notes": "버그 수정 및 성능 개선"
}
```

- **업데이트 있냐 / 없냐**
- **다운로드 받을 URL**
- **체크섬(hash)** 값을 같이 줘서 나중에 검증하게 함
- (보안 빡세면) **서명(signature)** 도 같이

---

## 3. 파일 다운로드 단계

클라이언트는 `download_url` 로 가서 파일을 받음:

```
GET https://cdn.example.com/my_app_1.2.0.exe
```

- 보통 대역폭을 위해 CDN 사용
- 모바일/데스크탑은 백그라운드 다운로드 많이 씀
  (사용자는 “업데이트 있어요” 뜨기 전에 이미 절반 받아놨을 수도 있음)

다운로드는 크게 두 방식:

1. **통째로 받은 다음 검증**
2. **스트리밍하면서 동시에 체크섬 계산** (메모리 절약)

---

## 4. 체크섬(Checksum) 검증 과정

### 4-1. 체크섬이 뭔데?

- **정의**: 파일 내용을 특정 알고리즘(SHA-256 등)으로 돌려서 나온 **고정 길이 문자열**
- **이유**: 파일이
  - 다운로드 중에 깨졌는지
  - 중간에 누가 바꿔치기 했는지
    빠르게 확인하려고

> 같은 알고리즘으로 같은 내용도는 항상 같은 결과
>
> 한 글자라도 바뀌면 완전 다른 값이 나옴

### 4-2. 클라이언트 쪽 검증 로직 (의사 코드)

```cpp
file = download("https://cdn.example.com/my_app_1.2.0.exe")

local_hash = sha256(file)
server_hash = "3f9a...abcd"

if local_hash != server_hash:
    // 검증 실패
    delete(file)
    show_error("업데이트 파일이 손상되었습니다. 다시 시도해주세요.")
else:
    // 통과
    proceed_install(file)
```

여기서 포인트:

- **hash 계산 알고리즘**은 서버와 클라가 동일해야 함 (SHA-256이면 둘 다 SHA-256)
- 보통 **SHA-256** 수준은 써야 함 (MD5/SHA-1은 충돌 이슈로 보안용으로는 비추)

---

## 5. 전자서명(Signature)까지 쓰는 경우 (보안 강화)

체크섬만으로는 “**손상 여부**”는 확인되지만

“**이 파일이 진짜 서버가 만든 거냐(위조 여부)**”는 보장이 안 됨.

그래서 종종 **공개키/개인키 기반 서명**을 같이 씀.

### 5-1. 서버 쪽

1. 빌드해서 `my_app_1.2.0.exe` 생성
2. SHA-256 해시 계산
3. 그 해시를 **서버의 개인키로 서명** → `signature`
4. `hash` + `signature`를 메타데이터로 같이 제공

### 5-2. 클라이언트 쪽

1. 파일 다운로드 후 SHA-256 해시 계산
2. 서버가 준 `signature` 를 **서버 공개키**로 검증

```cpp
isValid = verify_signature(
    public_key,
    message=local_hash,
    signature=server_signature
)

if !isValid:
    show_error("업데이트 파일이 신뢰할 수 없습니다.")
    abort()
```

- **체크섬 + 서명**까지 통과해야
  “안 깨졌고, 진짜 우리가 만든 파일"이라고 확신 가능

모바일 앱스토어(iOS/Android)는 이걸 **OS 레벨에서** 다 해주고 있고,

데스크탑 런처(스팀, 게임 런처 등)도 비슷한 개념을 씀.

---

## 6. 설치 / 교체 단계

검증 통과 후에야 설치를 시작함.

대표 패턴 몇 개:

1. **In-place 업데이트**
   - 기존 실행 파일 위에 덮어쓰기
   - 윈도우에서 실행 중인 exe는 바로 교체가 안 되어서
     보통 **업데이트 전용 런처/업데이터 프로세스**를 따로 띄움
2. **Side-by-side + 스위치**
   - `my_app_v1.0.3/`
   - `my_app_v1.2.0/`
   - 마지막에 심볼릭 링크나 바로가기만 새 버전으로 변경
   - 문제가 생기면 쉽게 이전 버전으로 **롤백** 가능
3. **패치(Delta 업데이트)**
   - 전체 파일이 아니라 “변경된 부분”만 내려받는 방식
   - 속도, 트래픽 절약
   - 이 경우도 **패치 적용 후 최종 파일에 대해 체크섬 검증** 다시 함

---

## 7. 체크섬이 깨졌을 때의 동작

일반적인 흐름은:

1. **재시도 1~N회**
2. 계속 안 되면:
   - “네트워크 상태를 확인해주세요” 같은 에러 메시지
   - 서버 로그에 기록 (특정 CDN 노드 문제일 수 있음)
3. 절대 **검증 실패 상태에서 설치 진행 X**

   → 여기 허용하면 바로 보안/장애 지옥

---

## 8. “사용자 입장에서 보이는 화면” 기준으로 정리하면

1. 앱 실행
2. “새 버전이 있습니다. 지금 업데이트할까요?” 팝업
3. (사용자가 허용) → “업데이트 다운로드 중… XX%”
4. 다운로드 뒤에 잠깐 “파일 검증 중…” (체크섬/서명 검증)
5. 검증 성공:
   - “업데이트 설치 중…”
   - 설치 완료 후 재시작
6. 검증 실패:
   - “업데이트 파일이 손상되어 다시 다운로드합니다.”
   - 자동 재시도 또는 “다시 시도” 버튼 표시

---

## 9. 서버 입장에서 준비해야 하는 것들

서버 쪽도 정리해보면:

1. 빌드 파이프라인에서
   - 앱/프로그램 빌드 → 산출물 생성
   - 해시(SHA-256 등) 계산
   - (선택) 개인키로 서명 생성
2. 버전 정보 DB/파일에 저장

```json
{
  "version": "1.2.0",
  "platform": "windows",
  "url": "https://cdn.example.com/my_app_1.2.0.exe",
  "hash_algo": "SHA-256",
  "hash_value": "3f9a...abcd",
  "signature": "..."
}
```

1. `/update/check` 같은 API에서 이 메타데이터를 내려줌
2. 파일은 CDN에 올려두고, 서버는 **메타데이터만** 제공하는 구조가 많음

---

## 10. 정리

> 클라이언트가 현재 버전을 서버에 보내면,
>
> 서버가 최신 버전과 다운로드 URL, 파일의 체크섬(SHA-256 같은 해시)과 서명 정보를 내려줍니다.
>
> 클라이언트는 파일을 다운로드한 뒤 같은 알고리즘으로 해시를 계산해서 서버가 준 값과 비교하고,
>
> 필요하면 공개키로 서명까지 검증한 다음에야 실제 설치를 진행합니다.
>
> 이 과정 덕분에 전송 중 손상이나 위, 변조를 막을 수 있고, 문제가 생긴 경우에는 재다운로드나 롤백 전략과 함께 안전하게 업데이트를 관리할 수 있습니다.
